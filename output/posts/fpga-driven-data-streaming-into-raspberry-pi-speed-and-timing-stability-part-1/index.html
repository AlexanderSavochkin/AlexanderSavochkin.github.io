<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>FPGA-Driven data streaming into Raspberry Pi through GPIO: Speed and timing stability. Part 1 | Alex Savochkin</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://alexandersavochkin.github.io/posts/fpga-driven-data-streaming-into-raspberry-pi-speed-and-timing-stability-part-1/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Alex Savochkin">
<link rel="prev" href="../unveiling-the-resolver-enigma-using-black-box-method-for-understanding-resolver-and-decoding-shaft-position-part-1/" title="Unveiling the Resolver Enigma. Using black box method for understanding resolver and decoding shaft position. Part 1" type="text/html">
<meta property="og:site_name" content="Alex Savochkin">
<meta property="og:title" content="FPGA-Driven data streaming into Raspberry Pi through GPIO: Speed and t">
<meta property="og:url" content="https://alexandersavochkin.github.io/posts/fpga-driven-data-streaming-into-raspberry-pi-speed-and-timing-stability-part-1/">
<meta property="og:description" content="Introduction
GPIO could be considered one of the options for transferring data at a relatively fast speed
into single-board computers (SBCs), such as the Raspberry Pi. Possible applications include
ca">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-03-04T17:07:21-08:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../">

            <span id="blog-title">Alex Savochkin</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.rst" id="sourcelink" class="nav-link">Source</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../pages/about/" class="nav-link">About</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">FPGA-Driven data streaming into Raspberry Pi through GPIO: Speed and timing stability. Part 1</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Alex Savochkin
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2024-03-04T17:07:21-08:00" itemprop="datePublished" title="2024-03-04 17:07">2024-03-04 17:07</time></a>
            </p>
                <p class="commentline">
    


            
        </p>
<p class="sourceline"><a href="index.rst" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <section id="introduction"><h2>Introduction</h2>
<p>GPIO could be considered one of the options for transferring data at a relatively fast speed
into single-board computers (SBCs), such as the Raspberry Pi. Possible applications include
capturing radio signals for software-defined radio (SDR) or processing data from a microphone
array: each microphone typically captures fewer than or equal to 48K samples per second,
and having a few tens or even hundreds of microphones can result in a significant transfer
rate that needs to be managed.</p>
<p>SBCs, like the Raspberry Pi 4, have substantial computing power and typically
a few gigabytes of RAM, in addition to exposed GPIO pins. The latter makes it easy
to connect them to external devices. Thus, using them as the core of a high-speed data
acquisition and processing system seems attractive.</p>
<p>There are two main approaches for transferring data to/from an SBC via GPIO:
polling (also known as bit-banging) and using DMA. Surprisingly, both can be done in
user space on RPi (although elevated privileges are needed). As shown in
<a class="reference external" href="https://github.com/hzeller/rpi-gpio-dma-demo">https://github.com/hzeller/rpi-gpio-dma-demo</a>, polling is faster, so we will use
polling in our experiments.</p>
<p>In ARM-based systems peripherals, such as UART, SPI, GPIO are typically memory-mapped,
so we can access them by reading and writing to the physical memory addresses corresponding to the
peripheral registers. In order to get access to the memory-mapped GPIO registers, we use mmap to map the
/dev/mem file (which provides physical view of the memory) into the program's address space.</p>
<p>One of the challenges with polling, though, is that SBCs typically run Linux or another general-purpose
operating system, so the CPU is a shared resource, and the system will interrupt our bit-banging process
from time to time, causing the data flow to stop. Consequently, the data stream has to be buffered on the device side.</p>
<p>We will consider a strategy to minimize interruption of the polling process and try see what transfer rate we can acheive
this way. We will also estimate the interruption time and the required buffer size on the device side which will allow not
to loose any data.</p>
</section><section id="reseving-a-cpu-core-for-polling"><h2>Reseving a CPU core for polling</h2>
<p>Turns out that the Linux kernel allows to "set aside" one or a few CPU cores, so the operation system
won't schedule any processes to run on that cores by default. However the system is still aware of
this "reserved" cores and processes can be explicitly assigned to these cores. There are a few
things here we must take into account: first of all, these isolated cores are still interrupted
by system clock. We expect the interruption time to be no more than a few tenths of microseconds,
but measuring it is one of the goals of this work.</p>
<p>The kernel command line parameter <code>isolcpu &lt;core&gt;</code> allows to "isolate set of CPU from disturbences".
Let's "isolate" 3rd core of RPi4 CPU "form disturbance": here is my kernel command line params file <code>cmdline.txt</code>:</p>
<pre class="literal-block">console=serial0,115200 console=tty1 ...[SKIPPED]... isolcpus=3</pre>
<p>The only change I made was adding <code>isolcpus=3</code> at the end of file.
Now, when you boot into the system you can use a tool like top/htop and confirm that 3rd core is allways idle.
It is possible to explicitly assign a process to that core:</p>
<pre class="literal-block">taskset -c 3 yes &gt; /dev/null &amp;</pre>
<p>Which starts a dummy process <code>yes &gt; /dev/null</code> on 3rd CPU core. Our strategy is to run the polling process on
the isolated core so we will have minimal interruptions from the OS.</p>
</section><section id="measuring-setup"><h2>Measuring setup</h2>
<p>To measure transfer rate and timing, we will build a simple timing device based on an FPGA,
which has a fast internal counting timer. The device waits for the rising edge of the
"Data Req" (data request) line and sets its 21-bit data output to the timer's value and the
"Data Rdy" (data ready) line. The polling program detects the change in the "Data Rdy"
line, reads and records the 21-bit data value from the parallel bus, and then sets "Data Req" to low on the SBC.
This signals to the timing device that the SBC has successfully read the data, prompting
it to set "Data Rdy" to low. The polling program detects the falling edge of the "Data Rdy"
line and proceeds to the next cycle iteration. The difference in consecutive data reads from
the timing device allows us to measure the time between loop iterations. We need to measure
two values: the average number of cycles per unit of time (to determine throughput) and
the maximum time between two iterations of the loop (to determine the required buffering size).</p>
<p>The reason we use a 21-bit data bus is that we hit the maximum number pins available on Icestick.
The number of GPIO pins on the Raspberry Pi is 28, and since the protocol uses 3 lines for control,
we have 25 pins remaining on the SBC side.</p>
<p>Here is the wiring diagram of the measuring setup:</p>
<img alt="/images/RPi-Timing-wiring.png" src="../../images/RPi-Timing-wiring.png" style="width: 773.0px; height: 480.0px;"><p>and its real-life appearance</p>
<img alt="/images/time-measuring-setup.jpg" src="../../images/time-measuring-setup.jpg" style="width: 320.0px; height: 240.0px;"><p>The exchange process described above can be visualized as follows:</p>
<img alt="/images/RPi-Timing-Sequence.png" src="../../images/RPi-Timing-Sequence.png" style="width: 675.0px; height: 675.0px;"><p>The polling program (left side of the diagram) is written in C. Here is the source code of the loop:</p>
<div class="code"><pre class="code C"><a id="rest_code_b5cdcc2574d54d4789006886c2262371-1" name="rest_code_b5cdcc2574d54d4789006886c2262371-1" href="#rest_code_b5cdcc2574d54d4789006886c2262371-1"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-2" name="rest_code_b5cdcc2574d54d4789006886c2262371-2" href="#rest_code_b5cdcc2574d54d4789006886c2262371-2"></a><span class="w">    </span><span class="c1">//Set the DATA_REQUEST signal to the device (25th GPIO pin)</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-3" name="rest_code_b5cdcc2574d54d4789006886c2262371-3" href="#rest_code_b5cdcc2574d54d4789006886c2262371-3"></a><span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">gpio_port</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_SET_OFFSET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">);</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-4" name="rest_code_b5cdcc2574d54d4789006886c2262371-4" href="#rest_code_b5cdcc2574d54d4789006886c2262371-4"></a>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-5" name="rest_code_b5cdcc2574d54d4789006886c2262371-5" href="#rest_code_b5cdcc2574d54d4789006886c2262371-5"></a><span class="w">    </span><span class="c1">//Wait for the DATA_READY signal from the device (27th GPIO pin)</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-6" name="rest_code_b5cdcc2574d54d4789006886c2262371-6" href="#rest_code_b5cdcc2574d54d4789006886c2262371-6"></a><span class="w">    </span><span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">gpio_port</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_LEV_OFFSET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">27</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-7" name="rest_code_b5cdcc2574d54d4789006886c2262371-7" href="#rest_code_b5cdcc2574d54d4789006886c2262371-7"></a>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-8" name="rest_code_b5cdcc2574d54d4789006886c2262371-8" href="#rest_code_b5cdcc2574d54d4789006886c2262371-8"></a><span class="w">    </span><span class="c1">//Read the data from the device, keeping only the lower 24 bits</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-9" name="rest_code_b5cdcc2574d54d4789006886c2262371-9" href="#rest_code_b5cdcc2574d54d4789006886c2262371-9"></a><span class="w">    </span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">gpio_port</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_LEV_OFFSET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFFFFFF</span><span class="p">;</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-10" name="rest_code_b5cdcc2574d54d4789006886c2262371-10" href="#rest_code_b5cdcc2574d54d4789006886c2262371-10"></a>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-11" name="rest_code_b5cdcc2574d54d4789006886c2262371-11" href="#rest_code_b5cdcc2574d54d4789006886c2262371-11"></a><span class="w">    </span><span class="c1">//Clear the DATA_REQUEST signal to the device</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-12" name="rest_code_b5cdcc2574d54d4789006886c2262371-12" href="#rest_code_b5cdcc2574d54d4789006886c2262371-12"></a><span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="n">gpio_port</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_CLR_OFFSET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">);</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-13" name="rest_code_b5cdcc2574d54d4789006886c2262371-13" href="#rest_code_b5cdcc2574d54d4789006886c2262371-13"></a>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-14" name="rest_code_b5cdcc2574d54d4789006886c2262371-14" href="#rest_code_b5cdcc2574d54d4789006886c2262371-14"></a><span class="w">    </span><span class="c1">//Wait for the DATA_READY signal from the device to be cleared</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-15" name="rest_code_b5cdcc2574d54d4789006886c2262371-15" href="#rest_code_b5cdcc2574d54d4789006886c2262371-15"></a><span class="w">    </span><span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">gpio_port</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">GPIO_LEV_OFFSET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">27</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<a id="rest_code_b5cdcc2574d54d4789006886c2262371-16" name="rest_code_b5cdcc2574d54d4789006886c2262371-16" href="#rest_code_b5cdcc2574d54d4789006886c2262371-16"></a><span class="p">}</span>
</pre></div>
<p>The FPGA code is written in Verilog. Here is some highlights of the timing device design. The icestick has
a 12 MHz reference clock, and we use it with PLL available on the ICE40 FPGA for generate 50.25 MHz internal
"fast" clock. So our timer resolution is approximatelly 20 ns. Here is how we declare the PLL in verilog:</p>
<div class="code"><pre class="code verilog"><a id="rest_code_88a41f93ec114c54a6000594450bda01-1" name="rest_code_88a41f93ec114c54a6000594450bda01-1" href="#rest_code_88a41f93ec114c54a6000594450bda01-1"></a><span class="kt">wire</span><span class="w"> </span><span class="n">clk</span><span class="p">;</span><span class="w"> </span><span class="c1">//Declare signal for 50.25MHz clock</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-2" name="rest_code_88a41f93ec114c54a6000594450bda01-2" href="#rest_code_88a41f93ec114c54a6000594450bda01-2"></a>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-3" name="rest_code_88a41f93ec114c54a6000594450bda01-3" href="#rest_code_88a41f93ec114c54a6000594450bda01-3"></a><span class="n">SB_PLL40_CORE</span><span class="w"> </span><span class="p">#(</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-4" name="rest_code_88a41f93ec114c54a6000594450bda01-4" href="#rest_code_88a41f93ec114c54a6000594450bda01-4"></a><span class="w">    </span><span class="p">.</span><span class="n">FEEDBACK_PATH</span><span class="p">(</span><span class="s">"SIMPLE"</span><span class="p">),</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-5" name="rest_code_88a41f93ec114c54a6000594450bda01-5" href="#rest_code_88a41f93ec114c54a6000594450bda01-5"></a><span class="w">    </span><span class="p">.</span><span class="n">PLLOUT_SELECT</span><span class="p">(</span><span class="s">"GENCLK"</span><span class="p">),</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-6" name="rest_code_88a41f93ec114c54a6000594450bda01-6" href="#rest_code_88a41f93ec114c54a6000594450bda01-6"></a><span class="w">    </span><span class="p">.</span><span class="n">DIVR</span><span class="p">(</span><span class="mh">4</span><span class="mb">'b0000</span><span class="p">),</span><span class="w"> </span><span class="c1">// DIVR = 0  // 12MHz * (DIVF + 1) / (DIVR + 1) = 50.25MHz</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-7" name="rest_code_88a41f93ec114c54a6000594450bda01-7" href="#rest_code_88a41f93ec114c54a6000594450bda01-7"></a><span class="w">    </span><span class="p">.</span><span class="n">DIVF</span><span class="p">(</span><span class="mh">7</span><span class="mb">'b1000010</span><span class="p">),</span><span class="w"> </span><span class="c1">// DIVF = 66</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-8" name="rest_code_88a41f93ec114c54a6000594450bda01-8" href="#rest_code_88a41f93ec114c54a6000594450bda01-8"></a><span class="w">    </span><span class="p">.</span><span class="n">DIVQ</span><span class="p">(</span><span class="mh">3</span><span class="mb">'b100</span><span class="p">),</span><span class="w"> </span><span class="c1">// DIVQ = 4</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-9" name="rest_code_88a41f93ec114c54a6000594450bda01-9" href="#rest_code_88a41f93ec114c54a6000594450bda01-9"></a><span class="w">    </span><span class="p">.</span><span class="n">FILTER_RANGE</span><span class="p">(</span><span class="mh">3</span><span class="mb">'b001</span><span class="p">)</span><span class="w"> </span><span class="c1">// FILTER_RANGE = 1</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-10" name="rest_code_88a41f93ec114c54a6000594450bda01-10" href="#rest_code_88a41f93ec114c54a6000594450bda01-10"></a><span class="p">)</span><span class="w"> </span><span class="n">pll</span><span class="w"> </span><span class="p">(</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-11" name="rest_code_88a41f93ec114c54a6000594450bda01-11" href="#rest_code_88a41f93ec114c54a6000594450bda01-11"></a><span class="w">    </span><span class="p">.</span><span class="n">REFERENCECLK</span><span class="p">(</span><span class="n">ref_clk</span><span class="p">),</span><span class="w"> </span><span class="c1">//Input 12MHz ICEStick clock</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-12" name="rest_code_88a41f93ec114c54a6000594450bda01-12" href="#rest_code_88a41f93ec114c54a6000594450bda01-12"></a><span class="w">    </span><span class="p">.</span><span class="n">PLLOUTCORE</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span><span class="w">       </span><span class="c1">//Output 50.25MHz clock</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-13" name="rest_code_88a41f93ec114c54a6000594450bda01-13" href="#rest_code_88a41f93ec114c54a6000594450bda01-13"></a><span class="w">    </span><span class="p">.</span><span class="n">LOCK</span><span class="p">(),</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-14" name="rest_code_88a41f93ec114c54a6000594450bda01-14" href="#rest_code_88a41f93ec114c54a6000594450bda01-14"></a><span class="w">    </span><span class="p">.</span><span class="n">RESETB</span><span class="p">(</span><span class="mh">1</span><span class="mb">'b1</span><span class="p">),</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-15" name="rest_code_88a41f93ec114c54a6000594450bda01-15" href="#rest_code_88a41f93ec114c54a6000594450bda01-15"></a><span class="w">    </span><span class="p">.</span><span class="n">BYPASS</span><span class="p">(</span><span class="mh">1</span><span class="mb">'b0</span><span class="p">)</span>
<a id="rest_code_88a41f93ec114c54a6000594450bda01-16" name="rest_code_88a41f93ec114c54a6000594450bda01-16" href="#rest_code_88a41f93ec114c54a6000594450bda01-16"></a><span class="p">);</span>
</pre></div>
<p>The <code>clk</code> signal is 50.25 MHz clock, provides synchronization. The main logic of the timing device (right part
of the exchagne diagram) can be described by the following verilog code:</p>
<div class="code"><pre class="code verilog"><a id="rest_code_efa6c94756ab47a1a284849552abb7b6-1" name="rest_code_efa6c94756ab47a1a284849552abb7b6-1" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-1"></a><span class="k">module</span><span class="w"> </span><span class="n">transfer_msr</span><span class="p">(</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-2" name="rest_code_efa6c94756ab47a1a284849552abb7b6-2" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-2"></a><span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="n">ref_clk</span><span class="p">,</span><span class="w">  </span><span class="c1">//ICEStick 12MHz clock</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-3" name="rest_code_efa6c94756ab47a1a284849552abb7b6-3" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-3"></a><span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="n">rst</span><span class="p">,</span><span class="w">      </span><span class="c1">//Reset signal from SBC</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-4" name="rest_code_efa6c94756ab47a1a284849552abb7b6-4" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-4"></a><span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="n">data_req</span><span class="p">,</span><span class="w"> </span><span class="c1">//Data request signal from SBC</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-5" name="rest_code_efa6c94756ab47a1a284849552abb7b6-5" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-5"></a><span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="n">data_rdy</span><span class="p">,</span><span class="w"> </span><span class="c1">//Data ready signal to SBC</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-6" name="rest_code_efa6c94756ab47a1a284849552abb7b6-6" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-6"></a><span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">23</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">msr_data</span><span class="w"> </span><span class="c1">//24-bit data to SBC</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-7" name="rest_code_efa6c94756ab47a1a284849552abb7b6-7" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-7"></a><span class="p">);</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-8" name="rest_code_efa6c94756ab47a1a284849552abb7b6-8" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-8"></a>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-9" name="rest_code_efa6c94756ab47a1a284849552abb7b6-9" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-9"></a><span class="w">    </span><span class="kt">reg</span><span class="w"> </span><span class="n">prev_data_req</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-10" name="rest_code_efa6c94756ab47a1a284849552abb7b6-10" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-10"></a><span class="w">    </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">23</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">timer_count</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-11" name="rest_code_efa6c94756ab47a1a284849552abb7b6-11" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-11"></a>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-12" name="rest_code_efa6c94756ab47a1a284849552abb7b6-12" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-12"></a><span class="w">    </span><span class="c1">//...[SKIPPED PLL declaration]...</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-13" name="rest_code_efa6c94756ab47a1a284849552abb7b6-13" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-13"></a>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-14" name="rest_code_efa6c94756ab47a1a284849552abb7b6-14" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-14"></a><span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-15" name="rest_code_efa6c94756ab47a1a284849552abb7b6-15" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-15"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w">  </span><span class="c1">//Reset the device on HIGH level of the reset signal</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-16" name="rest_code_efa6c94756ab47a1a284849552abb7b6-16" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-16"></a><span class="w">            </span><span class="n">msr_data</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">24</span><span class="mb">'b0</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-17" name="rest_code_efa6c94756ab47a1a284849552abb7b6-17" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-17"></a><span class="w">            </span><span class="n">timer_count</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">24</span><span class="mb">'b0</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-18" name="rest_code_efa6c94756ab47a1a284849552abb7b6-18" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-18"></a><span class="w">            </span><span class="n">prev_data_req</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">'b0</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-19" name="rest_code_efa6c94756ab47a1a284849552abb7b6-19" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-19"></a><span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">else</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-20" name="rest_code_efa6c94756ab47a1a284849552abb7b6-20" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-20"></a><span class="w">        </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-21" name="rest_code_efa6c94756ab47a1a284849552abb7b6-21" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-21"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_req</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">prev_data_req</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-22" name="rest_code_efa6c94756ab47a1a284849552abb7b6-22" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-22"></a><span class="w">                </span><span class="c1">//Data request detected, send the timer value to msr_data output</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-23" name="rest_code_efa6c94756ab47a1a284849552abb7b6-23" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-23"></a><span class="w">                </span><span class="n">msr_data</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">timer_count</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-24" name="rest_code_efa6c94756ab47a1a284849552abb7b6-24" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-24"></a><span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_req</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">prev_data_req</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-25" name="rest_code_efa6c94756ab47a1a284849552abb7b6-25" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-25"></a><span class="w">                </span><span class="c1">// Next cycle after the data request, set the data ready signal</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-26" name="rest_code_efa6c94756ab47a1a284849552abb7b6-26" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-26"></a><span class="w">                </span><span class="c1">// We set the output on the previous cycle</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-27" name="rest_code_efa6c94756ab47a1a284849552abb7b6-27" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-27"></a><span class="w">                </span><span class="n">data_rdy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">'b1</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-28" name="rest_code_efa6c94756ab47a1a284849552abb7b6-28" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-28"></a><span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">data_req</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-29" name="rest_code_efa6c94756ab47a1a284849552abb7b6-29" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-29"></a><span class="w">                </span><span class="c1">//Data request cleared, clear the data ready signal</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-30" name="rest_code_efa6c94756ab47a1a284849552abb7b6-30" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-30"></a><span class="w">                </span><span class="n">data_rdy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">'b0</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-31" name="rest_code_efa6c94756ab47a1a284849552abb7b6-31" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-31"></a><span class="w">            </span><span class="k">end</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-32" name="rest_code_efa6c94756ab47a1a284849552abb7b6-32" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-32"></a>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-33" name="rest_code_efa6c94756ab47a1a284849552abb7b6-33" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-33"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">24'hFFFFFF</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-34" name="rest_code_efa6c94756ab47a1a284849552abb7b6-34" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-34"></a><span class="w">                </span><span class="c1">//Roll over the timer</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-35" name="rest_code_efa6c94756ab47a1a284849552abb7b6-35" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-35"></a><span class="w">                </span><span class="n">timer_count</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">24</span><span class="mb">'b0</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-36" name="rest_code_efa6c94756ab47a1a284849552abb7b6-36" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-36"></a><span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-37" name="rest_code_efa6c94756ab47a1a284849552abb7b6-37" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-37"></a><span class="w">                </span><span class="c1">//Increment the timer</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-38" name="rest_code_efa6c94756ab47a1a284849552abb7b6-38" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-38"></a><span class="w">                </span><span class="n">timer_count</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">timer_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-39" name="rest_code_efa6c94756ab47a1a284849552abb7b6-39" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-39"></a><span class="w">            </span><span class="k">end</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-40" name="rest_code_efa6c94756ab47a1a284849552abb7b6-40" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-40"></a>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-41" name="rest_code_efa6c94756ab47a1a284849552abb7b6-41" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-41"></a><span class="w">            </span><span class="n">prev_data_req</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">data_req</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-42" name="rest_code_efa6c94756ab47a1a284849552abb7b6-42" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-42"></a><span class="w">        </span><span class="k">end</span><span class="p">;</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-43" name="rest_code_efa6c94756ab47a1a284849552abb7b6-43" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-43"></a><span class="w">    </span><span class="k">end</span>
<a id="rest_code_efa6c94756ab47a1a284849552abb7b6-44" name="rest_code_efa6c94756ab47a1a284849552abb7b6-44" href="#rest_code_efa6c94756ab47a1a284849552abb7b6-44"></a><span class="k">endmodule</span>
</pre></div>
<p>I use 24-bit counter because I am having I2S INMP441 microphone array as a possible follow-up project.
The resolution of the INMP441 microphone is 24 bits, so I want to have the same resolution for the timer.</p>
</section><section id="results"><h2>Results</h2>
<p>The program reads 500M values of the timer from the FPGA and records and dumps the raw 20 lower bits of the timer to a file.
I post-processed the file to calculate the time between two consecutive reads, so we can see the distribution of the time intervals.</p>
<p>Some observations: initially the typical timer increment between reads is aroun 42 timer clicks, here is the first 1000 reads</p>
<pre class="literal-block">42,   42,   41,    0,   84,   41,   42,   41,   42,   41,    0,
83,   42,   41,   42,   42,   41,   42,   42,   41,   42,   41,
41,   42,   42,   41,   42,    0,   83,   41,   43,   41,    0,
83,   41,   42,   41,   42,   41,   42,   42,   41,   42,   42,
41,   42,   42,   41,   41,   42,   42,   41,   42,   41,   42,
41,   42,   42,   41,   42,   41,    0,   84,   41,   42,   41,
42,   41,   42,   42,    0,   83,   42,   41,   41,   42,   42,
41,   42,   42,   41,   42,   42,   41,   42,   42,   42,   41,
41,   42,   41,   42,   41,   42,   42,    0,   83,   41,   42,
42,   41,   41,   42,   41,   42,   42,   41,   41,   42,   42,
43,   42,    0,   83,   41,   42,   41,    0,   84,   41,   42,
41,   42,   41,   42,   42,   42,   41,   42,   41,   42,   42,
42,   41,   42,   41,   41,   42,   42,   41,   42,    0,   83,
42,   42,    0,   83,   42,   41,   41,   42,    0,   83,  793,
-710,   42,   41,   42,   42,   42,   41,   42,   41,    0,   83,
42,   41,   42,   41,   42,   42,   41,   42,   42,   41,    0,
83,   42,   41,   42,    0,   83,   41,   43,   41,   42,   41,
0,   83,   41,   42,    0,   83,   42,   41,   42,   42,   41,
...</pre>
<p>Since the timer frequency is 50.25MHz, the typical time between reads is 42/50.25MHz = 0.836us, or approximatelly
1.2M reads per second.</p>
<p>After approximately 67K the typical time between reads decreases to 19 timer clicks, or 0.378us, or 2.6M reads per second.</p>
<pre class="literal-block">19,   15,   15,   15,   15,    0,   31,   18,   16,   19,   15,
19,   19,   19,   19,   19,   19,   19,   19,   15,   15,   15,
15,    0,   31,   19,   19,   19,   19,   19,    0,   34,   16,
19,    0,   34,   19,   19,   19,   15,   15,    0,   31,   19,
19,    0,   34,   19,   19,   16,   15,   15,   15,   16,    0,
34,   19,   19,   19,   19,   19,   19,   15,   16,   19,   19,
19,   19,   15,   19,   15,   15,   15,   15,   16,   19,   19,
19,    0,   34,   19,   19,   19,   19,   19,   19,    0,   34,
16,    0,   34,   15,   15,    0,   31,    0,   34,   19,   19,
19,   19,   19,   19,    0,   34,   19,    0,   34,   19,   19,
19,   19,   19,   19,   19,   19,   19,   19,    0,   34,   19,
19,   19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
15,   16,   19,   19,   19,   19,   19,   19,   19,   19,   19,
19,   16,   15,    0,   31,   19,   19,   19,   15,   19,   19,
0,   34,   19,   19,   15,   19,   19,   15,   15,   15,   16,
15,   19,   19,   15,   15,   15,   16,    0,    0,   49,   19,
19,   19,   19,   15,   15,   15,   16,    0,   34,   19,   19,
19,    0,   34,   19,   19,   19,   19,    0,   34,   19,  538,
-504,   15,   15,   15,    0,   31,   19,   19,   19,   19,   19,
16,   19,   19,   19,   19,   19,   19,   15,   19,   19,   19,
19,   19,   19,   19,   19,   19,    0,   34,   15,   16,   19,
19,   19,   19,   19,   19,   19,   19,   15,   16,   19,   19,</pre>
<p>The second observation is that sometimes the timer difference is 0, which means we read the same value twice. My
theory is that it is due to read/write operation reordering, and, perhaps, we need a memory barrier in the polling loop.
Although the <a class="reference external" href="https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf">perpheral guide for the BCM2711</a>
says that you don't need memory barriers if you work with the same peripheral (see page 6 of the guide).</p>
<p>The third observation is that sometimes the sometimes we get a negative value with a large magnitude and a "compensating" positive value
next to it: 19, 538, -504, 15. It is probably a glitch in the data, like noise in 9th bit of the parallel bus, corresponding to 512 (just a guess).</p>
<p>Occasionaly we have a few hundreds or even a couple of thousands of timer clicks between reads, which is probably due to the the OS interrupts.</p>
<p>Here is the histogram of the time intervals between reads for 500M cycles:</p>
<img alt="/images/FPGA-timing-hist1.png" src="../../images/FPGA-timing-hist1.png" style="width: 675.0px; height: 675.0px;"><img alt="/images/FPGA-timing-hist2.png" src="../../images/FPGA-timing-hist2.png" style="width: 675.0px; height: 675.0px;"></section><section id="conclusion-takeaways-future-work-and-follow-ups"><h2>Conclusion, Takeaways, Future Work and Follow-ups</h2>
<ol class="arabic simple">
<li><p>I really loved working with IceStick and IceStorm tools. It is a great platform for learning and prototyping.
Hovewer, the number of exposed pins is very limited, and we hit the limit here</p></li>
<li><p>Looks like the approach we used here allows us to connect around 20 microphones safely, and we probably need
to push the speed further to connect more microphones. The bottleneck seems to be on the SBC side, I need to
understand if it is possible to squeeze more speed out of the SBC. Another option would be using more powerful
FPGA with big RAM attached to it and moving some of the DSP processing to the FPGA.</p></li>
</ol>
<ol class="arabic simple" start="4">
<li><p>I need to understand the nature of the glitches in the data get rid of them, if possible.</p></li>
<li><p>The next step would be to connect a bunch of I2S microphones to the FPGA and transfer real audio data to the SBC.</p></li>
</ol></section>
</div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../unveiling-the-resolver-enigma-using-black-box-method-for-understanding-resolver-and-decoding-shaft-position-part-1/" rel="prev" title="Unveiling the Resolver Enigma. Using black box method for understanding resolver and decoding shaft position. Part 1">Previous post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    


        </section></article><!--End of body content--><footer id="footer">
            Contents Â© 2024         <a href="mailto:alexandr.savochkin@gmail.com">Alex Savochkin</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
